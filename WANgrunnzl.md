---
timezone: UTC+8
---

> 请在上边的 timezone 添加你的当地时区(UTC)，这会有助于你的打卡状态的自动化更新，如果没有添加，默认为北京时间 UTC+8 时区


# 王均怡

1. 大家好，我是智能科学与技术大三的王均怡，这是第一次接触区块链和web3，希望可以在这次学习中收获大大滴多。
2. yes i can
3. 你的联系方式（推荐 Telegram）tele: 7582846432

## Notes

<!-- Content_START -->

### 2025.03.31

----------------------Web3的核心思想-------------------------\
·去中心化\
-数据由用户和网络共同拥有，不需要机构/平台/公司去管理\
-依赖区块链、P2P网络、分布式存储（IPFS、Arweave）

·Self-Sovereignty\
-用户可以拥有并管理自己的身份（DID）、资产（NFT、Token）和数据\
-不用依赖于中心化的平台（微信/支付宝/银行）

·Permissionless\
-任何人都有权限参与网络，无需审核

·可组合性\
-不同的协议可以像乐高一样组合

----------------------Web的关键组件-------------------------\
·区块链\
-比特币、以太坊

·智能合约\
-自动转账、NFT铸造

·token经济\
-功能型代币、治理代币、NFT

·去中心化身份\
-用户自己控制身份，不依赖使用其他平台的账号登录

----------------------Web3的主要应用场景-------------------------\
·去中心化金融\
-借贷、交易所、稳定币

·NFT 与数字所有权

·去中心化自治组织\
-用代码和Token治理代替公司制

·元宇宙\
-虚拟世界 + 数字资产经济

### 2025.04.01
学习了区块链技术相关课程https://b23.tv/hO7Rt1U\
·两种最主要加密货币：以太坊ETH（区块链2.0）、比特币BTC（区块链1.0）\
-以太坊：以太坊（Ethereum）是一个开源的、去中心化的区块链平台.它不仅支持加密货币，还可以运行智能合约和去中心化应用。\
-以太坊共识机制：早期为Proof of Work，后来发展为Proof of Stake\
-以太坊的区块时间：12秒（而比特币需要10分钟）\
-以太坊的总供应量：无上限（而比特币仅有2100万枚）

·superchain整体架构分为三层：协议层、核心模块、基础组件\
其中协议层和核心模块分为五个部分：共识、合约、账本、网络和安全；基础组件包括：日志组件、存储组件、监控组件、密码学库和基础组件\
-Optimism Superchain 是由 Optimism 提出的 以太坊 Layer 2 扩展架构，旨在连接多个Optimistic Rollup，提供高吞吐量、低成本的区块链生态。通过利用 Rollup 技术将大量交易打包，减少以太坊主网的负担。并且Superchain 内部的 Rollup 之间可以无缝通信，实现更好的跨链体验。

### 2025.04.02
学习了智能合约的开发过程\
-语言：Solidity（一种面向智能合约的高级编程语言）\
以下是一段简单的智能合约代码示例：\
// 指定 Solidity 的版本\
pragma solidity ^0.8.0;
 
// 定义一个合约\
contract SimpleStorage {\
    // 声明一个状态变量，用于存储整数值\
    uint256 private storedData;\
    // 定义一个事件，用于记录状态变量的变化\
    event ValueChanged(uint256 newValue);\ 
    // 合约构造函数，在部署合约时执行一次，用于初始化状态变量\
    constructor() {\
        storedData = 0;\
    }\
    // 设置整数值的函数，只有合约的拥有者可以调用\
    function set(uint256 newValue) public {\
        storedData = newValue;\
        emit ValueChanged(newValue);\
    }\
    // 获取整数值的函数，可以被任何人调用\
    function get() public view returns (uint256) {\
        return storedData;\
    }\
}
其中set函数，允许合约的拥有者设置整数值；get 函数，允许任何人查看存储的整数值。\
-使用这个合约的方法：部署到本地链、测试网或主网部署->通过 ethers.js 与合约交互->在 Etherscan 上验证代码->部署到以太坊主网（需 Gas 费）

·区块链的共识机制
PoW（工作量证明）：矿工通过计算哈希值来竞争记账权，最快解出数学难题的矿工可以打包交易并获得奖励\
特点：高度去中心化，安全性强但高能耗、交易速度慢\
PoS（权益证明）：持有更多代币的用户更有可能被选为验证者，无需挖矿，直接质押代币即可参与共识。\
特点：能耗低、快，但容易导致富人更富和遭遇攻击\
DPoS（委托权益证明）：代币持有者投票选出一部分“超级节点”来负责记账，超级节点轮流打包交易。\
特点：高效但容易导致少数超级节点掌控网络\
PBFT（拜占庭容错）：所有验证节点需要经过多轮通信达成共识，防止恶意节点作恶。\
特点：速度快能耗低但只适用于小规模网络，难以扩展

### 2025.04.03
·今天学习了Layer 1 vs. Layer 2 \
可以把区块链的L1和L2想象成城市交通：\
L1 是主路，比如比特币或以太坊本身，负责最基础的安全和交易结算，但主路拥堵时速度慢、费用高（比如堵车还要付高额过路费）。
L2 是高架桥或地铁，比如比特币的闪电网络或以太坊的Rollup，它在主路之外处理大量小额交易，最后只把结果传回主路。这样更快更便宜（比如地铁不堵车，票价低），但安全性仍依赖主路。
简单来说，L1是根基，L2是提速工具，两者配合解决“又安全又高效”的问题。
·搞明白了一直以来的一个疑问：为什么需要区块链？传统技术不行吗？数据库也能记账，但需要管理员：比如支付宝的账本由阿里控制，用户必须信任它。
区块链是“无管理员”的数据库：规则由代码决定，权力分散给所有参与者。\
传统系统像“租房中介”，你要交佣金还要担心跑路。
区块链像“智能合约租房”，自动打款给房东，中介失业了。


### 2025.04.04
·比特币最开始是怎么分发的\
1.按规则创世区块应有50 BTC奖励，但这些币无法被花费\
2.早期分发方式：挖矿是唯一途径\
·分发的公平性设计\
无预挖争议：中本聪的比特币也是通过公开挖矿获得（尽管他占了早期大部分算力）。\
代码开源：任何人可参与，规则透明。\
去中心化启动：没有公司或机构控制初始分发。\
·比特币的价值如何定义\
核心原则：供需决定价格。没有央行或公司控制比特币价格，完全由买卖双方在市场中博弈形成。\
交易所是价格发现场所：比如币安、Coinbase等平台，全球用户在此挂单交易，实时价格由最新成交价决定。\
·价格形成的具体过程\
步骤1：你在交易所挂单“1 BTC = 30,000美元卖出”，另一个人挂“1 BTC = 29,500美元买入”。\
步骤2：当市场多数人认为价格该涨时，买方提高报价（如30,100美元），卖方跟涨，价格上升。\
步骤3：如果突然出现利空（如某国禁令），大量人抛售，买方压价，价格下跌。\
本质：价格反映的是人们对未来需求的预期，如同艺术品或黄金。\
·欺诈证明（Fraud Proof）：让普通用户（非全节点）也能验证交易是否有效，而不必信任矿工或验证者。比特币的L2支付通道，依赖欺诈证明防止资金被盗。\
全节点验证太慢，对于普通用户来说可以用欺诈证明让轻节点可以挑战可疑交易，由全节点提供证明。\
过程是默认所有交易都是有效的（“乐观”信任）。如果有人提交了无效交易，其他人可以在挑战期（如7天）内提交欺诈证明。\
·公钥 = 你的“银行账号”（可公开）。\
私钥 = 你的“密码”（必须保密）。\
交易签名：用私钥签名，全网用公钥验证你是否真的授权了这笔交易。\


### 2025.04.05
·optimism超级链（Superchain） 是以太坊Layer 2网络的一种模块化扩展方案，基于 OP Stack（Optimism的开发框架）构建。它允许开发者快速部署高度互操作的区块链，这些链共享安全性和通信协议，形成一个多链网络，而非孤立的单个Rollup。\
·OP Stack：超级链的“操作系统”\
想象 以太坊主网 是一家总仓库，但顾客太多，结账又慢又贵。\
Optimism超级链 的解决方案是： 在总仓库旁边开多家连锁超市（OP Stack链），\
Base超市：专门卖日用品（Coinbase的链，主打交易）。\
Zora超市：专门卖艺术品（NFT链）。\
Reddit超市：卖社区积分（Reddit的链）。\
所有超市共用同一个进货系统（以太坊主网保证安全），但各自优化货架摆放（链的规则）。\
OP Stack 是Optimism提供的 区块链乐高套装，包含：\
积木块1：结算层（默认是以太坊，像乐高底板）。\
积木块2：执行层（处理交易，像拼装模块）。\
积木块3：数据存储（可选Celestia等，像装饰零件）。\
总结：Optimism超级链 = 用同一套标准（OP Stack）开多家分店（链），所有分店共享总店（以太坊）的信用，但各自优化服务。\

### 2025.04.06
请假

### 2025.04.07
了解了区块链在机器学习上的应用https://ieeexplore.ieee.org/abstract/document/10338875/authors#authors\
这篇论文探讨了机器学习与区块链技术的结合，提出了一个名为 SuperChain 的去中心化框架，用于在区块链上高效训练机器学习算法。\
设计理念：提出的系统 SuperChain 包含三种类型的参与者，第一种是发布训练数据的数据节点，监督学习任务（或训练算法）具有最低要求，例如最低准确度值和奖励。第二种是共识节点或矿工，他们致力于解决宣布的训练任务或执行训练；最后是验证节点，他们评估模型并选择最佳模型或最佳解决方案并更新区块链。主要思想是，当数据节点宣布任务时，共识节点相互竞争并在数据节点定义的时间段内执行监督学习训练，以构建新模型。这些模型发布在区块链上。当数据节点发布测试集时，验证节点会进行共识，选出性能最佳的最优解决方案。该解决方案保存在区块中，并添加到不可修改的链中，并且可以追溯。最后，数据节点将任务奖励分发给获胜的共识节点。\
去中心化特点：通过分布式网络来确保数据的安全性和完整性，使得参与者可以在没有信任基础的情况下进行数据分析。\
实验结果：SuperChain 框架提高了监督学习模型的效率，同时保证了模型的可靠性和可信度。\
SuperChain 的架构，由三层组成：\
数据层：允许将监督学习数据存储在点对点版本控制的分布式文件系统（IPFS）上。\
区块链层：涉及区块链相关的所有过程，如：创世块构建、块验证、所有节点之间达成共识的执行、选择最佳的监督学习和更新区块链。\
机器学习层：涉及共识和验证节点执行的决策过程、监督式机器学习算法及其性能评估。\
SuperChain 是一个无需许可的区块链，参与者无需经过身份验证，可以以匿名方式加入网络，甚至可以扮演任何角色。系统中定义了三种类型的角色：\
数据节点：在区块链网络上委托机器学习任务和数据的节点。\
共识节点：是系统计算能力的提供者，它们竞争训练出符合数据节点指定要求的模型。获胜的共识节点将获得数据节点指定的奖励。\
验证节点：对共识节点发布的机器学习模型进行排名和评估，对最佳模型达成共识，并向包含获胜模型的链中提出新的区块。\

### 2025.04.08
阅读了op的文档，解答了一些疑惑https://docs.optimism.io/superchain/superchain-explainer
1.为什么要合并多个区块链？\
-将多个区块链合并成一个统一的OP超级链可以提高整体网络的效率和可扩展性，并且管理起来更加简单。\
不同链之间互相操作起来也更方便，从而为用户提供更快、更便宜和更可靠的交易体验。\
2.传统多链架构的根本问题\
每条新链（比如不同的L1公链如以太坊、Solana、Avalanche）都有自己的安全验证体系（共识机制、验证节点等）\
就像每家银行都自己印钞票且互不认账，整个金融系统的风险会越来越高。并且每条新链需要招募自己的验证者（矿工/节点），这些节点需要投入硬件和质押代币。\
因此超级链的核心优势在于通过共享安全性和标准化协议，解决传统多链系统的碎片化问题。\
所有L2链（或子链）直接复用L1（如以太坊、Cosmos Hub）的共识机制和验证者网络。\
3.技术上的实现：\
L2链将区块头/状态根定期提交到L1（如以太坊），由L1验证者最终确认。\
采用欺诈证明（Optimistic Rollup）或零知识证明（ZK-Rollup）确保L2状态正确性。\
Optimism的Bedrock架构：每2分钟将L2交易批次压缩后锚定到以太坊。\
L1验证者同时验证多条L2链（如Cosmos Hub验证者为子链生产区块）。\
通过Slashing机制惩罚作恶节点，保障子链安全。\
tarkNet的L1-L2共享AMM：用户可在L2交易，结算在L1完成\
在L1部署共享流动性池（如Uniswap v4的Hooks），所有L2链直接访问。\
根据需求动态调整L2链的区块大小/Gas限制，通过L1拍卖机制分配资源。\
使用多线程虚拟机（如Move VM）或分片技术提升L2吞吐量。\

### 2025.04.09
学习了这篇论文https://ieeexplore.ieee.org/abstract/document/10466953\
1.为什么选择最合适的 Layer-2 区块链可扩展性解决方案？特别是针对特定的应用场景，比如电子投票系统或供应链溯源系统。\
-不同的区块链应用对性能、效率、安全等方面的需求不一样，所以不能“一刀切”，必须根据具体应用选择合适的 Layer-2 技术。\
比如，电子投票 vs. 供应链，它们的交易类型、数据结构、处理方式都不一样。\
3.如何评估各类Layer-2解决方案的有效性？ 
-需要考虑吞吐量（每秒可处理的交易数量）、最终确认时间（较短的最终确认时间可以提高用户信任度，减少交易被否决的风险）、费用是否降低\
安全性、操作性和去中心化程度\
高安全+隐私 → 投票系统\
高互操作+数据完整性 → 供应链\
高吞吐+低成本 → DeFi / 游戏\
4.几种扩容方案\
-Rollup： rollup 是一种 Layer-2 扩容解决方案，可将多笔交易打包成一批，从而缩短处理时间并降低链下交易的 Gas 费用。\
它在不牺牲安全性和去中心化程度的前提下提升了区块链的扩容能力，并催生了去中心化交易所、游戏平台和小额支付等新用例。然而，实\
现 Rollup 解决方案需要大量的开发资源，并且可能产生初始设置成本。交易处理延迟也可能影响用户体验。\
如下所述，Rollup 可以分为两大类：乐观 Rollup和ZK Rollup。\
-状态通道：状态通道是一种区块链可扩展性解决方案，允许各方在链下更新其共享状态，从而减少区块链上记录的交易数量。它提高了可扩\
展性，可用于资产管理、隐私支付渠道和在线游戏等各种应用。智能合约跟踪状态并验证更新，同时提供争议解决。状态通道通过数字签名等\
技术提供更高的可扩展性、交易隐私性和安全性。状态通道，例如闪电网络和雷电网络，有可能显著提高交易吞吐量、降低交易费用并提高速度，\
特别是对于需要快速结算时间的小额支付。\
-侧链：侧链是附加在主区块链上的独立区块链，无需修改主区块链即可创建新特性和功能。用户可以将其加密货币或资产从主区块链转移到侧链\，
反之亦然，从而实现更复杂的交易和去中心化的应用程序开发。与传统区块链相比，侧链具有诸多优势，包括更快、更高效的交易，以及更大的应\
用程序开发灵活性，同时避免主区块链的中断。侧链区块链的例子包括比特币的 Liquid和以太坊的 Rootstock 。\
-Optimistic Rollups：Optimistic Rollups 是以太坊的 Layer-2 扩容解决方案，它将多笔交易聚合成一个批次，然后再提交到以\
太坊主区块链。Optimistic Rollups 默认假设批次中的所有交易都是有效的。这种乐观的假设使得 Rollups 能够快速处理交易。然而，\
这也带来了批次中可能包含无效交易的可能性。为了解决这个问题，Optimistic Rollups 依赖于一种防欺诈机制。任何人都可以通过提交防欺\
诈证明来质疑批次中的某笔交易，证明该交易无效。如果提交了防欺诈证明，整个批次将被拒绝并回滚。由于存在被抓的风险，它可以阻止无效交易。\
-ZK-rollups：零知识汇总 (ZK-rollups) 是一种区块链的 Rollup 扩容机制，它将多笔链下交易打包，并生成加密证明来证明交易的有效性。\
该证明和交易数据的压缩版本会发布在底层区块链（Layer-1）上。由于该证明能够显示交易的有效性，且不会泄露交易细节，因此被称为“零知识”\
证明。ZK-rollups 能够大幅提升交易吞吐量并降低交易费用，同时仍然保留 Layer-1 区块链的安全性。\




### 2025.04.10
看了一看op stack的本地部署。

OP Stack 的部署过程依赖于一组 JSON 配置文件，告诉系统在部署 L2 时：  
使用哪个 L1 链？  
从哪个 block 开始同步？  
L2 的 genesis 区块如何设定？  
各种链参数（区块时间、初始费用、地址等）是多少？  
本地部署时，我们通常会使用 Hardhat 起一个本地 L1 链（chainId: 31337），并部署一个 L2（chainId: 420）。所以就需要这个脚本帮你把这些设定写入一个配置文件。

看了一下朋友的文件，她的:
```bash
const { task } = require("hardhat/config");
const fs = require("fs");
const path = require("path");

module.exports = {
  solidity: "0.8.9",
  networks: {
    "getting-started": {
      url: "http://127.0.0.1:8545", // Hardhat 默认 RPC
      accounts: [
        "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80" // Hardhat 默认私钥
      ]
    }
  }
};

// ✅ 自定义任务：生成 OP Stack 部署配置文件
task("generate-deploy-config", "Generate deploy config for a network")
  .addParam("name", "The name of the deploy-config file to generate (e.g. local)")
  .setAction(async (taskArgs, hre) => {
    const config = {
      l1ChainID: 31337,
      l2ChainID: 420,
      l1StartingBlockTag: "latest",
      l2OutputOracleStartingTimestamp: 0,
      l1BlockTimeSeconds: 2,
      l2BlockTimeSeconds: 2,
      l2GenesisBlockGasLimit: "15000000",
      l2GenesisChainID: 420,
      l2GenesisBaseFeePerGas: "0x3b9aca00",
      l2GenesisL1FeeRecipient: "0x4200000000000000000000000000000000000011",
      l2GenesisSequencerAddress: "0x4200000000000000000000000000000000000011",
      l2GenesisStateRoot: "0x0000000000000000000000000000000000000000000000000000000000000000"
    };

    const outputPath = path.join(__dirname, "deploy-config", `${taskArgs.name}.json`);
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath, JSON.stringify(config, null, 2));

    console.log(`✅ Generated deploy config at: ${outputPath}`);
  }); 
```

我研究了一下这段代码为什么这样写：  
```bash
const config = {
  l1ChainID: 31337,
```
设置本地 L1 的 chain ID，Hardhat 默认是 31337。

```bash
  l2ChainID: 420,
```
L2 网络的 chain ID。在 OP Stack 的测试中，420 是经典的默认值（也是 Optimism Goerli 的链 ID）。

```bash
  l1StartingBlockTag: "latest",
```
告诉 OP Stack 从当前本地 L1 的最新区块作为起始区块进行同步。这在本地开发中最方便。

 l2OutputOracleStartingTimestamp: 0,
通常是 OP Stack 的 L2 Oracle 启动的时间戳，这里设为 0 表示从时间戳为0的地方开始（开发用）。

```bash
  l1BlockTimeSeconds: 2,
  l2BlockTimeSeconds: 2,
```
指定 L1 和 L2 的区块时间（以秒为单位），2秒是开发用的快节奏设置，有利于快速测试。

```bash
  l2GenesisBlockGasLimit: "15000000",
```
L2 初始区块的 Gas 上限，设为 15M 是比较典型的值，符合 EIP-1559 建议。

```bash
  l2GenesisChainID: 420,
```
L2 的链 ID，必须和 l2ChainID 一致。

```bash
  l2GenesisBaseFeePerGas: "0x3b9aca00",
```
L2 的 genesis 区块起始 base fee（单位为 wei），0x3b9aca00 = 1 Gwei。

```bash
  l2GenesisL1FeeRecipient: "0x4200000000000000000000000000000000000011",
  l2GenesisSequencerAddress: "0x4200000000000000000000000000000000000011",
```
L2 初始区块中设置的费用接收者和 sequencer 地址。0x420...11 是 OP Stack 中用于测试的“魔法地址”（magic address），本地部署时建议这样设。

```bash
  l2GenesisStateRoot: "0x000...000",
```
初始化的状态根，0 值表示我们不使用预加载状态，也是一种开发简化方式。


<!-- Content_END -->
